%\documentclass{report}
\documentclass[oneside]{book}
\usepackage{fullpage}
\usepackage{setspace}
\usepackage{parskip}
\setcounter{secnumdepth}{0}
\begin{document}
\title{The Practical and Ethical Consequences of United States Software Patent Law}
\author{Matthew Kline, , Tyler Kuske, Creighton Long}
\begin{titlepage}
\vspace*{\fill}
\begin{Large}
\begin{center}
\textbf{LED Shooting Range Post-Project Report}

Matthew Kline, Creighton Long, Tyler Kuske, and James Gordon \\
Computer Engineering \\
University of Wisconsin-Madison \\
May 9, 2014
\end{center}
\end{Large}
\vspace*{\fill}
\end{titlepage}
\pagenumbering{roman}
\frontmatter
\begin{Large}
\begin{center}
\textbf{Executive Summary}
\end{center}
\end{Large}

\noindent
It is a period of civil war. Rebel \\
spaceships, striking from a hidden \\
base, have won their first victory \\
against the evil Galactic Empire. \\

\noindent
During the battle, Rebel spies managed \\
to steal secret plans to the Empire's \\
ultimate weapon, the Death Star, an \\
armored space station with enough \\
power to destroy an entire planet. \\

\noindent
Pursued by the Empire's sinister agents, \\
Princess Leia races home aboard her \\
starship, custodian of the stolen plans \\
that can save her people and restore \\
freedom to the galaxy...
\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}
\mainmatter

\section{Initial Design}

\subsection{Overview}

Our initial design called for an infrared shooting range.
The setup was to consist of multiple targets and ``guns'',
combined with a daughter board to interface them with the ZedBoard.
The ZedBoard was to run the game state machine and communicate via the daughter board
with the peripherals.
Guns would contain an IR-emitting diode used to ``fire'' a shot,
a piezo buzzer for additional user feedback,
and LEDs for indicating game state and for use in debugging.
Targets would contain IR diodes for detecting ``shots,''
as well as LEDs to indicate target state and for use in debugging.
Multiple games were to be supported,
including multiplayer ones and single-player drills.
Statistics would be collected during the game and displayed at the end of a match
along with players' scores.

\subsection{Hardware}

Three different PCBs were to be designed---one for the targets, one for the guns,
and one for the daughter board.
Each would contain a TI MSP430 microcontroller, which would be used for processing
as well as wireless communications.
The ZedBoards FPGA would be minimized and used mainly for routing,
with some switch and LED functionality for configuration.
Most (if not all) logic was to be done in software for more rapid design and debugging.

\subsection{Software}

As mentioned above, software was to handle as much logic as possible,
simplifying the hardware and FPGA designs.
Targets were to differentiate between guns by having each gun emit a unique
sequence of IR pulses, which would be resolved by the targets to a gun ID.

On the ZedBoard, the game control software was to be written in C++.
The control software would communicate with the peripherals, track game state,
and report the game results back to users.
A message protocol would be developed so that game events including querying controllers,
registering shots, changing target states, and so on could be passed as messages
between the various software components.

To interface with players, the UI would run on a separate machine.
In order to make the UI platform and framework-independent,
the ZedBoard software was to contain a TCP server.
Messages in the same format as described above would be passed in a JSON encoding,
with some sort of delimiter between messages.

\section{Implementation}

\subsection{Software}

Software development proceeded mainly as-expected, though here too,
time estimates were too short and time could have been better utilized.
Development began with the messaging system,
which served as the underpinning of the rest of the software.
After the messages were largely completed,
work progressed to the development of the game state machine,
followed by the TCP server used to communicate with the UI.
The TCP server was constructed using Boost.Asio,
an asynchronous networking library in Boost,
the de-facto ``non-standard standard'' set of C++ libraries.
Messages were passed between components using a thread-safe message queue,
which allowed the game state machine and server to run in separate threads
with minimal hassle.

To help ensure code quality and decouple software development with hardware development,
unit tests were written for the messages, their serialization to and from JSON,
and other components as they were written.
Unit testing became less comprehensive towards the end of the project for two main reasons:
\begin{enumerate}
\item Networking and user input-dependent code are harder to test than pure computational code.
\item Incoming deadlines dictated the development focus on actual project code and not meta-work.
\end{enumerate}

\end{document}
